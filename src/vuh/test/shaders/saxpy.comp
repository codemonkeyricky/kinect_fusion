#version 440

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;             // workgroup size set with specialization constant
layout(push_constant) uniform Parameters {  // push constants
   mat4 rotation; 
   vec4 translation; 
   mat4 intrinsics; 
   uint dw;
   uint dh;
   uint l;
} params;

layout(std430, binding = 0) buffer lay0 { float depth[]; }; // array parameters
layout(std430, binding = 1) buffer lay1 { float tsdf[]; };
layout(std430, binding = 2) buffer lay2 { float weight[]; };

void main(){
   const uint x = gl_GlobalInvocationID.x; // current offset
   const uint y = gl_GlobalInvocationID.y; // current offset
   const uint z = gl_GlobalInvocationID.z; // current offset
   // if(params.size <= id){                   // drop threads outside the buffer
   //    return;
   // }
   uint k = x * params.l * params.l + y * params.l + z;
   tsdf[k] = k; 
   weight[k] = -k;
}


/* 
#version 320 es

layout(local_size_x = 64) in;



layout(binding = 0) readonly buffer Input0 {
    mat4 data; 
} rotation;

layout(binding = 1) readonly buffer Input1 {
    vec4 data; 
} translation;

layout(binding = 2) readonly buffer Input2 {
    mat4 data; 
} intrinsics;

layout(binding = 3) readonly buffer Input3 {
    float data[];
} depth;

layout(binding = 4) buffer Input4 {
    float data[];
} tsdf_array;

layout(binding = 5) buffer Input5 {
    float data[];
} weight_in;

layout(binding = 6) buffer Output0 {
    float data[];
} tsdf_out;

layout(binding = 6) buffer Output1 {
    float data[];
} weight_out;

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

tsdf_out.data[x] = 1.0f;

    // float TRUNCATION = -0.06f;
    // float MINF = -1000000000.0f;

    // vec4 pg = vec4(x, y, z, 0); 
    // vec4 pc = rotation.data[0] * pg + translation.data;

    uint k = x *4u  ; //+ y * 4u + z; 

    // tsdf_array.data[0]= 1.0f;

    #if 0
    uint k = gl_GlobalInvocationID.x;
    vec4 pg = world.data[k];
    vec4 pc = rotation.data[0] * pg + translation.data;
    ivec4 pi = ivec4(intrinsics.data[0] * pc); 
    if (pi[0] >= 0 && pi[0] < 640 && pi[0] >= 0 && pi[1] < 480) 
    {
        // calculate the sdf value
        float lambda = length(pc / pc[2]);
		float d = depth.data[pi[1] * 640 + pi[0]];
        float sdf = d - length((pg - translation.data) / lambda); 

        if (sdf >= TRUNCATION && d != MINF) 
        {
            float current_tsdf = min(1.0f, sdf / TRUNCATION);
            float current_weight = 1.0f;
            float old_tsdf = tsdf_array.data[k];
            float old_weight = weight_array.data[k];

            float updated_tsdf = (old_weight * old_tsdf + current_weight * current_tsdf) / (old_weight + current_weight);
            float updated_weight = old_weight + current_weight;

            tsdf_array.data[k] = updated_tsdf;
            weight_array.data[k] = updated_weight;
        }
    }
    #endif
};
 */ 