#version 440

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;             // workgroup size set with specialization constant
layout(push_constant) uniform Parameters {  // push constants
   mat4 rotation; 
   vec4 translation; 
   mat4 intrinsics; 
   uint dw;
   uint dh;
   uint l;
} params;

layout(std430, binding = 0) buffer lay0 { float depth[]; }; // array parameters
layout(std430, binding = 1) buffer lay1 { uint tsdf_array[]; };
layout(std430, binding = 2) buffer lay2 { uint weight_array[]; };

void main() {
    uint k = gl_GlobalInvocationID.x;

    float TRUNCATION = -0.06f;
    float MINF = -1000000000.0f;

    uint tsdf_in = tsdf_array[k];
    uint weight_in = weight_array[k];
    uint tsdf_out = 0;
    for (uint i = 0; i < 4; ++i)
    {
        // actual index
        uint kk = k * 4 + i;

        uint shift = i * 8;
        uint mask = 0xff << shift;

        uint z = kk % 256;
        uint y = (kk / 256 ) % 256; 
        uint x = kk / 256 / 256; 

        // in
        float tsdf = float((tsdf_in & mask) >> shift) / 127.0f;
        float weight = float((weight_in & mask) >> shift);

        vec4 pg = vec4(x, y, z, 0); 
        vec4 pc = params.rotation * pg + params.translation;
        ivec4 pi = ivec4(params.intrinsics * pc); 

        if (pi[0] >= 0 && pi[0] < 640 && pi[0] >= 0 && pi[1] < 480) 
        {
            float lambda = length(pc / pc[2]);
    		float d = depth[pi[1] * 640 + pi[0]];
            float sdf = d - length((pg - params.translation) / lambda); 

            if(sdf >= TRUNCATION && d != MINF) 
            {
                float current_tsdf = min(1.0f, sdf / TRUNCATION);
                float current_weight = 1.0f;
                float old_tsdf = tsdf_array[k];
                float old_weight = weight_array[k];

                float updated_tsdf = (old_weight * old_tsdf + current_weight * current_tsdf) / (old_weight + current_weight);
                float updated_weight = old_weight + current_weight;

                uint tsdfi = uint(updated_tsdf / 127.0f);
                tsdf_out |= (tsdfi & 0xff) << shift;

                uint weighti = max(uint(updated_weight), 255); 
                tsdf_out |= (tsdfi & 0xff) << shift;
            }

        }

        /*
         * 
         */

        // out
    }
    tsdf_array[k] = tsdf_out;

    // if (pi[0] >= 0 && pi[0] < 640 && pi[0] >= 0 && pi[1] < 480) 
    // {
    //     // calculate the sdf value

    //     if(sdf >= TRUNCATION && d != MINF) 
    //     {
    //         float current_tsdf = min(1.0f, sdf / TRUNCATION);
    //         float current_weight = 1.0f;
    //         float old_tsdf = tsdf_array[k];
    //         float old_weight = weight_array[k];

    //         float updated_tsdf = (old_weight * old_tsdf + current_weight * current_tsdf) / (old_weight + current_weight);
    //         float updated_weight = old_weight + current_weight;

    //         tsdf_array[k] = updated_tsdf;
    //         weight_array[k] = updated_weight;
    //     }

    //     tsdf_array[k] = k; 
    //     for(uint i = 0; i < 40; ++i)
    //         tsdf_array[k] = sqrt(tsdf_array[k]);
    //     weight_array[k] = k;
    // }
}


/* 
tsdf_out.data[x] = 1.0f;

    // float TRUNCATION = -0.06f;
    // float MINF = -1000000000.0f;

    // vec4 pg = vec4(x, y, z, 0); 
    // vec4 pc = rotation.data[0] * pg + translation.data;

    uint k = x *4u  ; //+ y * 4u + z; 

    // tsdf_array.data[0]= 1.0f;

    #if 0
    uint k = gl_GlobalInvocationID.x;
    vec4 pg = world.data[k];
    vec4 pc = rotation.data[0] * pg + translation.data;
    ivec4 pi = ivec4(intrinsics.data[0] * pc); 
    if (pi[0] >= 0 && pi[0] < 640 && pi[0] >= 0 && pi[1] < 480) 
    {
        // calculate the sdf value
        float lambda = length(pc / pc[2]);
		float d = depth.data[pi[1] * 640 + pi[0]];
        float sdf = d - length((pg - translation.data) / lambda); 

        if (sdf >= TRUNCATION && d != MINF) 
        {
            float current_tsdf = min(1.0f, sdf / TRUNCATION);
            float current_weight = 1.0f;
            float old_tsdf = tsdf_array.data[k];
            float old_weight = weight_array.data[k];

            float updated_tsdf = (old_weight * old_tsdf + current_weight * current_tsdf) / (old_weight + current_weight);
            float updated_weight = old_weight + current_weight;

            tsdf_array.data[k] = updated_tsdf;
            weight_array.data[k] = updated_weight;
        }
    }
    #endif
};
 */ 